open import Relation.Binary using (DecidableEquality)

module Term.Properties {name : Set} (_≟ₙ_ : DecidableEquality name) where

open import Data.List using ([]; _∷_)
open import Data.Product using (_,_)
open import Function.Base using (flip)
open import Relation.Binary.PropositionalEquality using (_≡_; refl; sym; cong)
open import Relation.Nullary using (yes; no; contradiction; map′)

open import Term
open import TypeChecker.Type.Properties _≟ₙ_ renaming (_≟_ to _≟ₜ_)

-- there HAS to be a better way to do this
_≟_ : DecidableEquality Term
(` x) ≟ (` y) = map′ (cong `_) (λ { refl → refl }) (x ≟ₙ y)
(` x) ≟ (ƛ y :: t ⇒ b) = no λ ()
(` x) ≟ (p · b) = no λ ()
(` x) ≟ rec x₁ = no λ ()
(` x) ≟ get x₁ b = no λ ()
(` x) ≟ `zero = no λ ()
(` x) ≟ `suc b = no λ ()
(` x) ≟ `pos b = no λ ()
(` x) ≟ `negsuc b = no λ ()
(ƛ x :: x₁ ⇒ a) ≟ (` x₂) = no λ ()
(ƛ x :: t ⇒ a) ≟ (ƛ y :: u ⇒ b) with x ≟ₙ y
... | no ¬eq = no (λ { refl → contradiction refl ¬eq })
... | yes refl with t ≟ₜ u
... | no ¬eq = no (λ { refl → contradiction refl ¬eq })
... | yes refl with a ≟ b
... | no ¬eq = no (λ { refl → contradiction refl ¬eq })
... | yes refl = yes refl
(ƛ x :: x₁ ⇒ a) ≟ (b · b₁) = no λ ()
(ƛ x :: x₁ ⇒ a) ≟ rec x₂ = no λ ()
(ƛ x :: x₁ ⇒ a) ≟ get x₂ b = no λ ()
(ƛ x :: x₁ ⇒ a) ≟ `zero = no λ ()
(ƛ x :: x₁ ⇒ a) ≟ `suc b = no λ ()
(ƛ x :: x₁ ⇒ a) ≟ `pos b = no λ ()
(ƛ x :: x₁ ⇒ a) ≟ `negsuc b = no λ ()
(a · a₁) ≟ (` x) = no λ ()
(a · a₁) ≟ (ƛ x :: x₁ ⇒ b) = no λ ()
(f · a) ≟ (g · b) with f ≟ g
... | no ¬eq = no (λ { refl → contradiction refl ¬eq })
... | yes refl with a ≟ b
... | no ¬eq = no (λ { refl → contradiction refl ¬eq })
... | yes refl = yes refl
(a · a₁) ≟ rec x = no λ ()
(a · a₁) ≟ get x b = no λ ()
(a · a₁) ≟ `zero = no λ ()
(a · a₁) ≟ `suc b = no λ ()
(a · a₁) ≟ `pos b = no λ ()
(a · a₁) ≟ `negsuc b = no λ ()
rec x ≟ (` x₁) = no (λ ())
rec x ≟ (ƛ x₁ :: x₂ ⇒ b) = no (λ ())
rec x ≟ (b · b₁) = no (λ ())
rec [] ≟ rec [] = yes refl
rec [] ≟ rec (x ∷ xs) = no (λ ())
rec (x ∷ m) ≟ rec [] = no (λ ())
rec ((kx , vx) ∷ xs) ≟ rec ((ky , vy) ∷ ys)  with kx ≟ₙ ky | vx ≟ vy | rec xs ≟ rec ys
... | no ¬p | no ¬q | no ¬r = no (λ { refl → contradiction refl ¬p })
... | no ¬p | yes refl | no ¬r = no (λ { refl → contradiction refl ¬p })
... | yes refl | no ¬q | no ¬r = no (λ { refl → contradiction refl ¬q })
... | yes refl | yes refl | no ¬eq = no (λ { refl → contradiction refl ¬eq })
... | no ¬p | no ¬q | yes refl = no (λ { refl → contradiction refl ¬p })
... | no ¬p | yes refl | yes refl = no (λ { refl → contradiction refl ¬p })
... | yes refl | no ¬q | yes refl = no (λ { refl → contradiction refl ¬q })
... | yes refl | yes refl | yes refl = yes refl
rec x ≟ get x₁ b = no (λ ())
rec x ≟ `zero = no (λ ())
rec x ≟ `suc b = no (λ ())
rec x ≟ `pos b = no (λ ())
rec x ≟ `negsuc b = no (λ ())
get x a ≟ (` x₁) = no (λ ())
get x a ≟ (ƛ x₁ :: x₂ ⇒ b) = no (λ ())
get x a ≟ (b · b₁) = no (λ ())
get x a ≟ rec x₁ = no (λ ())
get x a ≟ get y b with x ≟ₙ y
... | no ¬eq = no (λ { refl → contradiction refl ¬eq })
... | yes refl with a ≟ b
... | no ¬eq = no (λ { refl → contradiction refl ¬eq })
... | yes refl = yes refl
get x a ≟ `zero = no (λ ())
get x a ≟ `suc b = no (λ ())
get x a ≟ `pos b = no (λ ())
get x a ≟ `negsuc b = no (λ ())
`zero ≟ (` x) = no (λ ())
`zero ≟ (ƛ x :: x₁ ⇒ b) = no (λ ())
`zero ≟ (b · b₁) = no (λ ())
`zero ≟ rec x = no (λ ())
`zero ≟ get x b = no (λ ())
`zero ≟ `zero = yes refl
`zero ≟ `suc b = no (λ ())
`zero ≟ `pos b = no (λ ())
`zero ≟ `negsuc b = no (λ ())
`suc a ≟ (` x) = no (λ ())
`suc a ≟ (ƛ x :: x₁ ⇒ b) = no (λ ())
`suc a ≟ (b · b₁) = no (λ ())
`suc a ≟ rec x = no (λ ())
`suc a ≟ get x b = no (λ ())
`suc a ≟ `zero = no (λ ())
`suc a ≟ `suc b = map′ (cong `suc) (λ { refl → refl }) (a ≟ b)
`suc a ≟ `pos b = no (λ ())
`suc a ≟ `negsuc b = no (λ ())
`pos a ≟ (` x) = no (λ ())
`pos a ≟ (ƛ x :: x₁ ⇒ b) = no (λ ())
`pos a ≟ (b · b₁) = no (λ ())
`pos a ≟ rec x = no (λ ())
`pos a ≟ get x b = no (λ ())
`pos a ≟ `zero = no (λ ())
`pos a ≟ `suc b = no (λ ())
`pos a ≟ `pos b = map′ (cong `pos) (λ { refl → refl }) (a ≟ b)
`pos a ≟ `negsuc b = no (λ ())
`negsuc a ≟ (` x) = no λ ()
`negsuc a ≟ (ƛ x :: x₁ ⇒ b) = no λ ()
`negsuc a ≟ (b · b₁) = no λ ()
`negsuc a ≟ rec x = no λ ()
`negsuc a ≟ get x b = no λ ()
`negsuc a ≟ `zero = no (λ ())
`negsuc a ≟ `suc b = no (λ ())
`negsuc a ≟ `pos b = no (λ ())
`negsuc a ≟ `negsuc b = map′ (cong `negsuc) (λ { refl → refl }) (a ≟ b)
